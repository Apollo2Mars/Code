+ ## CS-Dynamic Planning
	+ Reference websites:
		+ http://www.cnblogs.com/kkgreen/archive/2011/06/26/2090702.html
		+ 一些例子：
			+ http://blog.csdn.net/uestclr/article/details/50760563
	+ Classical Problem:
		+ 有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法。
		+ 给定一个矩阵m，从左上角开始每次只能向右走或者向下走，最后达到右下角的位置，路径中所有数字累加起来就是路径和，返回所有路径的最小路径和，如果给定的m如下，那么路径1,3,1,0,6,1,0就是最小路径和，返回12.
			1 3 5 9
			8 1 3 4
			5 0 6 1
			8 8 4 0
		+ 给定数组arr，返回arr的最长递增子序列的长度，比如arr=[2,1,5,3,6,4,8,9,7]，最长递增子序列为[1,3,4,8,9]返回其长度为5.
		+ 最长公共子序列（LCS:Longest Common Subsequence）：
			+ 用途：**计算文本之间的相似度**
			+ 给定两个字符串str1和str2，返回两个字符串的最长公共子序列，例如：str1="1A2C3D4B56",str2="B1D23CA45B6A","123456"和"12C4B6"都是最长公共子序列，返回哪一个都行。
		+ 背包问题
			+ 背包问题，动态规划经典问题，一个背包有额定的承重W，有N件物品，每件物品都有自己的价值，记录在数组V中，也都有自己的重量，记录在数组W中，每件物品只能选择要装入还是不装入背包，要求在不超过背包承重的前提下，选出的物品总价值最大。
				+ 分析：假设物品编号从1到n，一件一件的考虑是否加入背包，假设dp[x][y]表示前x件物品，不超过重量y的时候的最大价值，枚举一下第x件物品的情况：
					情况1：如果选择了第x件物品，则前x-1件物品得到的重量不能超过y-w[x]。
					情况2：如果不选择第x件物品，则前x-1件物品得到的重量不超过y。
					所以dp[x][y]可能等于dp[x-1][y],也就是不取第x件物品的时候，价值和之前一样，也可能是dp[x-1][y-w[x]]+v[x],也就是拿第x件物品的时候，当然会获得第x件物品的价值。两种可能的选择中，应该选择价值较大的那个，也就是：
					$dp[x][y] = max{dp[x-1][y],dp[x-1][y-w[x]]+v[x]}$
					因此，对于dp矩阵来说，行数是物品的数量n，列数是背包的重量w，从左到右，从上到下，依次计算出dp值即可。

		+ 最长回文子串 (LPS:Longest Palindromic Substring)
			+ dp[i][j] 表示从i到j的子串是否是回文子串
			+ 如果s[i] == s[j],那么是否为回文子串取决于 dp[i+1][i-1]
			+ 如果s[i] != s[j],那么dp[i][j] 直接false